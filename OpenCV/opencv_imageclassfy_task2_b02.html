<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>opencv_imageclassfy_task2_b02</title>
    
    <!-- CSS æ¡†æ¶ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
    
    <!-- ä»£ç¢¼é«˜äº® -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/base16/darcula.min.css">
    
    <!-- è‡ªå®šç¾©æ¨£å¼ -->
    <style>
        
                body {
                    max-width: 900px;
                    margin: 0 auto;
                    padding: 20px;
                }
                /* æå‡ä»£ç å—å¯¹æ¯”åº¦ */
                pre {
                    background: #1e1e1e !important;
                    border: 1px solid #3e3e3e;
                }
                pre code {
                    background: #1e1e1e !important;
                }
                code {
                    background: #2d2d2d !important;
                }
                /* å¼•ç”¨å—å¯¹æ¯”åº¦ */
                blockquote {
                    background: #2d2d2d;
                    border-left: 4px solid #4a9eff;
                }
            
        
        /* é€šç”¨ä»£ç¢¼å¡Šæ¨£å¼ */
        pre code {
            display: block;
            padding: 1.5em;
            border-radius: 8px;
            overflow-x: auto;
            line-height: 1.6;
        }

        /* Mermaid åœ–è¡¨æ¨£å¼ */
        
        .mermaid {
            margin: 2em 0;
            padding: 1.5em;
            text-align: center;
            border-radius: 8px;
        }
        
        .mermaid {
            background: #2c3034;
            border: 1px solid #444;
        }
            
        
        /* éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container, .markdown-body, .latex-body, .window-body, .nes-container {
                padding: 15px;
            }
            pre code {
                padding: 1em;
            }
        }
        
        
    </style>
</head>
<body>
    <div class="container"><!-- Path: General_python/openCV/å½±åƒè¾¨è­˜-å‚³çµ±æ–¹æ³• | Timestamp: 2025-10-06 18:00:00 | Version: b02 -->
<h1>é¡Œç›®äºŒï¼šç´…ç¶ ç‡ˆè¾¨è­˜ç³»çµ±</h1>
<h2>ğŸ“‹ ä»»å‹™èªªæ˜</h2>
<p>è«‹æ’°å¯«ä¸€å€‹ Python ç¨‹å¼ï¼Œèƒ½å¤ è¾¨è­˜åœ–ç‰‡ä¸­çš„ç´…ç¶ ç‡ˆï¼Œåµæ¸¬ç´…ã€é»ƒã€ç¶ ä¸‰ç¨®ç‡ˆè™Ÿçš„ç‹€æ…‹ï¼Œä¸¦åœ¨ç•«é¢ä¸Šæ¨™ç¤ºå‡ºç•¶å‰äº®èµ·çš„ç‡ˆè™Ÿï¼ˆä¾‹å¦‚ï¼šã€Œç´…ç‡ˆã€ã€ã€Œç¶ ç‡ˆã€ç­‰ï¼‰ã€‚</p>
<hr />
<h2>ğŸ–¼ï¸ å½±åƒé¸æ“‡æŒ‡å¼•</h2>
<h3>é©åˆçš„å½±åƒé¡å‹</h3>
<h4>âœ… æ¨è–¦ä½¿ç”¨çš„å½±åƒ</h4>
<ol>
<li><strong>æ¸…æ™°çš„ç´…ç¶ ç‡ˆç…§ç‰‡</strong></li>
<li>ç‰¹å¾µï¼šç´…ç¶ ç‡ˆæ¸…æ™°å¯è¦‹ã€ç‡ˆè™Ÿæ˜äº®</li>
<li>è·é›¢ï¼š5-30 å…¬å°ºå…§æ‹æ”</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜…â˜…â˜…ï¼ˆ95%+ï¼‰</li>
<li>
<p>æœ€ä½³ç¯„ä¾‹ï¼š<br />
<code>âœ… ç™½å¤©æ‹æ”çš„ç´…ç¶ ç‡ˆï¼ˆå…‰ç·šå……è¶³ï¼‰
     âœ… ç‡ˆè™Ÿæ¸…æ™°ç™¼å…‰ï¼ˆç´…/é»ƒ/ç¶ å…¶ä¸­ä¸€å€‹äº®ï¼‰
     âœ… ç´…ç¶ ç‡ˆåœ¨ç•«é¢ä¸­å¤®ã€ä½”æ¯”é©ä¸­
     âœ… èƒŒæ™¯ç›¸å°ç°¡å–®ï¼ˆå¤©ç©ºã€å»ºç¯‰ç‰©ï¼‰</code></p>
</li>
<li>
<p><strong>ç›´è¦–è§’åº¦æ‹æ”</strong></p>
</li>
<li>ç‰¹å¾µï¼šé¡é ­æ­£å°ç´…ç¶ ç‡ˆï¼Œéæ¥µç«¯ä»°è§’æˆ–ä¿¯è§’</li>
<li>è§’åº¦å»ºè­°ï¼š<br />
<code>âœ… æ­£é¢ç›´è¦–ï¼ˆ0-15Â°ï¼‰     â†’ æœ€ä½³
     âš ï¸ å¾®å´é¢ï¼ˆ15-30Â°ï¼‰      â†’ å°šå¯
     âŒ å¤§è§’åº¦å´é¢ï¼ˆ&gt;45Â°ï¼‰    â†’ æ•ˆæœå·®
     âŒ æ¥µç«¯ä»°è§’/ä¿¯è§’ï¼ˆ&gt;60Â°ï¼‰ â†’ ç‡ˆè™Ÿå¯èƒ½è®Šå½¢</code></li>
<li>
<p>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜…â˜…â˜†ï¼ˆ85%+ï¼‰</p>
</li>
<li>
<p><strong>å–®ä¸€ç´…ç¶ ç‡ˆç‚ºä¸»</strong></p>
</li>
<li>ç‰¹å¾µï¼šç•«é¢ä¸­ä¸»è¦æ˜¯ä¸€çµ„ç´…ç¶ ç‡ˆ</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜…â˜…â˜…ï¼ˆ90%+ï¼‰</li>
<li>
<p>ç¯„ä¾‹ï¼š<br />
<code>âœ… è·¯å£å–®ä¸€ç´…ç¶ ç‡ˆ
     âœ… è¡Œäººå°ˆç”¨ç´…ç¶ ç‡ˆ
     âš ï¸ å¤šçµ„ç´…ç¶ ç‡ˆï¼ˆå¯èƒ½æ··æ·†ï¼‰
     âŒ é è™•å°å‹ç´…ç¶ ç‡ˆï¼ˆåƒç´ ä¸è¶³ï¼‰</code></p>
</li>
<li>
<p><strong>å…‰ç·šå……è¶³çš„ç…§ç‰‡</strong></p>
</li>
<li>ç‰¹å¾µï¼šç™½å¤©æˆ–å‚æ™šã€ç‡ˆè™Ÿæ¸…æ™°ç™¼å…‰</li>
<li>æ‹æ”æ™‚é–“ï¼š<br />
<code>âœ… ç™½å¤©æ™´å¤©          â†’ æœ€ä½³ï¼ˆå°æ¯”æ¸…æ™°ï¼‰
     âœ… é™°å¤©              â†’ è‰¯å¥½
     âœ… å‚æ™š/æ¸…æ™¨         â†’ å°šå¯ï¼ˆç‡ˆè™Ÿè¼ƒäº®ï¼‰
     âš ï¸ å¤œé–“              â†’ éœ€è¦èª¿æ•´åƒæ•¸
     âŒ é€†å…‰              â†’ ç‡ˆè™Ÿå¯èƒ½éæ›</code></li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜…â˜…â˜†ï¼ˆ85%+ï¼‰</li>
</ol>
<h4>âš ï¸ æ•ˆæœè¼ƒå·®çš„å½±åƒ</h4>
<ol>
<li><strong>èƒŒæ™¯è¤‡é›œçš„ç…§ç‰‡</strong></li>
<li>å•é¡Œï¼š<ul>
<li>èƒŒæ™¯æœ‰ç´…è‰²æ‹›ç‰Œã€ç´…ç£šç‰† â†’ èª¤åˆ¤ç´…ç‡ˆ</li>
<li>èƒŒæ™¯æœ‰ç¶ è‰²æ¤ç‰©ã€è‰åœ° â†’ èª¤åˆ¤ç¶ ç‡ˆ</li>
<li>å»£å‘Šçœ‹æ¿çš„å½©è‰²ç‡ˆå…‰ â†’ å¹²æ“¾åµæ¸¬</li>
</ul>
</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜†â˜†â˜†ï¼ˆ50-70%ï¼‰</li>
<li>
<p>æ”¹å–„æ–¹æ³•ï¼š</p>
<ul>
<li>æé«˜è¼ªå»“é¢ç©é–¾å€¼</li>
<li>åŠ å…¥åœ“å½¢åº¦æª¢æ¸¬</li>
<li>ä½¿ç”¨æ›´ç²¾ç¢ºçš„ HSV ç¯„åœ</li>
</ul>
</li>
<li>
<p><strong>ç‡ˆè™Ÿä¸äº®æˆ–å¾®å¼±</strong></p>
</li>
<li>å•é¡Œï¼š<ul>
<li>ç™½å¤©ç‡ˆè™Ÿé—œé–‰ â†’ é¡è‰²ä¸æ˜é¡¯</li>
<li>ç‡ˆè™Ÿæ•…éšœé–ƒçˆ â†’ å¯èƒ½åµæ¸¬ä¸åˆ°</li>
<li>ç‡ˆè™Ÿè¢«é®æ“‹ â†’ éƒ¨åˆ†å¯è¦‹</li>
</ul>
</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜†â˜†â˜†ï¼ˆ40-60%ï¼‰</li>
<li>
<p>æœ€ä½³ç‹€æ…‹ï¼šè‡³å°‘ä¸€å€‹ç‡ˆè™Ÿæ¸…æ™°ç™¼å…‰</p>
</li>
<li>
<p><strong>ç´…ç¶ ç‡ˆéå°æˆ–éé </strong></p>
</li>
<li>å•é¡Œï¼šç‡ˆè™Ÿåƒç´ ä¸è¶³ï¼ˆ&lt; 10Ã—10 pxï¼‰</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜†â˜†â˜†â˜†ï¼ˆ20-40%ï¼‰</li>
<li>
<p>æœ€å°å°ºå¯¸å»ºè­°ï¼šæ¯å€‹ç‡ˆè™Ÿè‡³å°‘ 15Ã—15 åƒç´ </p>
</li>
<li>
<p><strong>å¤©æ°£ä¸ä½³çš„ç…§ç‰‡</strong></p>
</li>
<li>å•é¡Œï¼š<ul>
<li>å¤§é›¨ã€å¤§éœ§ â†’ è¦–ç·šæ¨¡ç³Š</li>
<li>é›ªå¤© â†’ ç´…ç¶ ç‡ˆè¢«é›ªè¦†è“‹</li>
<li>å¼·çƒˆé™½å…‰åå°„ â†’ éæ›</li>
</ul>
</li>
<li>åµæ¸¬æˆåŠŸç‡ï¼šâ˜…â˜…â˜†â˜†â˜†ï¼ˆ30-60%ï¼‰</li>
</ol>
<h4>âŒ å®Œå…¨ä¸é©åˆçš„å½±åƒ</h4>
<ul>
<li>é»‘ç™½ç…§ç‰‡ï¼ˆç„¡è‰²å½©è³‡è¨Šï¼‰</li>
<li>æ¥µåº¦æ¨¡ç³Šæˆ–æ™ƒå‹•çš„ç…§ç‰‡</li>
<li>ç´…ç¶ ç‡ˆå®Œå…¨ç†„æ»…çš„ç…§ç‰‡</li>
<li>ç´…ç¶ ç‡ˆè¢«å®Œå…¨é®æ“‹</li>
<li>æ¥µç«¯é€†å…‰å°è‡´éæ›</li>
</ul>
<h3>ä¸åŒç´…ç¶ ç‡ˆé¡å‹çš„å½±åƒéœ€æ±‚</h3>
<h4>æ¨™æº–ç›´ç«‹å¼ç´…ç¶ ç‡ˆ</h4>
<pre class="codehilite"><code>æ§‹é€ ï¼šä¸Šç´…ã€ä¸­é»ƒã€ä¸‹ç¶ ï¼ˆå‚ç›´æ’åˆ—ï¼‰
æœ€ä½³æ‹æ”ï¼š
âœ… æ­£é¢æ‹æ”ï¼Œä¸‰å€‹ç‡ˆéƒ½æ¸…æ™°å¯è¦‹
âœ… å…¶ä¸­ä¸€å€‹ç‡ˆæ˜äº®ç™¼å…‰
âœ… è·é›¢é©ä¸­ï¼ˆ5-20mï¼‰

å½±åƒç‰¹å¾µï¼š
- ä¸‰å€‹åœ“å½¢ç‡ˆè™Ÿå‚ç›´æ’åˆ—
- ç‡ˆè™Ÿå¤§å°ç›¸ä¼¼
- é–“è·å‡å‹»
</code></pre>

<h4>æ©«å¼ç´…ç¶ ç‡ˆ</h4>
<pre class="codehilite"><code>æ§‹é€ ï¼šå·¦ç´…ã€ä¸­é»ƒã€å³ç¶ ï¼ˆæ°´å¹³æ’åˆ—ï¼‰
æœ€ä½³æ‹æ”ï¼š
âœ… å¹³è¦–è§’åº¦
âœ… é¿å…æ¥µç«¯å´è§’

å½±åƒç‰¹å¾µï¼š
- ä¸‰å€‹åœ“å½¢ç‡ˆè™Ÿæ°´å¹³æ’åˆ—
- ç‡ˆè™Ÿå¤§å°ç›¸ä¼¼
</code></pre>

<h4>è¡Œäººè™ŸèªŒ</h4>
<pre class="codehilite"><code>æ§‹é€ ï¼šä¸Šç´…ï¼ˆç«™ç«‹äººå½¢ï¼‰ã€ä¸‹ç¶ ï¼ˆè¡Œèµ°äººå½¢ï¼‰
æœ€ä½³æ‹æ”ï¼š
âœ… æ¸…æ™°å¯è¦‹äººå½¢ç¬¦è™Ÿ
âœ… ç‡ˆè™Ÿæ˜äº®

æ³¨æ„ï¼š
æœ¬é¡Œç›®ä¸»è¦é‡å°åœ“å½¢è»Šè¼›ç´…ç¶ ç‡ˆ
è¡Œäººè™ŸèªŒå¯ä½œç‚ºé€²éšæŒ‘æˆ°
</code></pre>

<h3>æ¸¬è©¦å½±åƒå»ºè­°</h3>
<h4>åˆå­¸è€…æ¸¬è©¦ï¼ˆé›£åº¦ï¼šâ˜…â˜†â˜†â˜†â˜†ï¼‰</h4>
<p><strong>è‡ªè¡Œå»ºç«‹ç°¡å–®æ¸¬è©¦åœ–</strong></p>
<pre class="codehilite"><code class="language-python"># å»ºç«‹æ¨¡æ“¬ç´…ç¶ ç‡ˆåœ–ç‰‡
import numpy as np
import cv2

# å»ºç«‹ 600x400 æ·±ç°è‰²ç•«å¸ƒï¼ˆæ¨¡æ“¬å¤©ç©º/èƒŒæ™¯ï¼‰
img = np.ones((600, 400, 3), dtype=np.uint8) * 100

# ç¹ªè£½ç´…ç¶ ç‡ˆå¤–æ¡†ï¼ˆé»‘è‰²çŸ©å½¢ï¼‰
cv2.rectangle(img, (150, 100), (250, 450), (30, 30, 30), -1)

# ç¹ªè£½ä¸‰å€‹ç‡ˆè™Ÿä½ç½®ï¼ˆæ·±ç°è‰²åœ“å½¢ = ç†„æ»…ç‹€æ…‹ï¼‰
cv2.circle(img, (200, 180), 35, (60, 60, 60), -1)  # ç´…ç‡ˆä½ç½®
cv2.circle(img, (200, 300), 35, (60, 60, 60), -1)  # é»ƒç‡ˆä½ç½®
cv2.circle(img, (200, 420), 35, (60, 60, 60), -1)  # ç¶ ç‡ˆä½ç½®

# è®“å…¶ä¸­ä¸€å€‹ç‡ˆäº®èµ·ï¼ˆä¾‹å¦‚ï¼šç´…ç‡ˆï¼‰
cv2.circle(img, (200, 180), 35, (0, 0, 255), -1)  # ç´…ç‡ˆäº®

cv2.imwrite('test_traffic_light.jpg', img)
</code></pre>

<p><strong>ç‰¹é»</strong>ï¼š<br />
- èƒŒæ™¯ç°¡å–®ï¼Œç„¡å¹²æ“¾<br />
- ç‡ˆè™Ÿæ¸…æ™°ã€é¡è‰²é£½å’Œ<br />
- é æœŸçµæœï¼š100% åµæ¸¬æˆåŠŸ</p>
<h4>ä¸­ç´šæ¸¬è©¦ï¼ˆé›£åº¦ï¼šâ˜…â˜…â˜…â˜†â˜†ï¼‰</h4>
<p><strong>æ‹æ”çœŸå¯¦ç´…ç¶ ç‡ˆ</strong></p>
<pre class="codehilite"><code>å»ºè­°å ´æ™¯ï¼š
1. è·¯å£ç´…ç¶ ç‡ˆï¼ˆç™½å¤©ã€æ™´å¤©ï¼‰
2. è·é›¢ 10-15 å…¬å°º
3. ä½¿ç”¨æ‰‹æ©Ÿç›¸æ©Ÿæ‹æ”
4. æ­£é¢è§’åº¦

æ‹æ”è¦é»ï¼š
- ç¢ºä¿è‡³å°‘ä¸€å€‹ç‡ˆè™Ÿäº®èµ·
- èƒŒæ™¯ç›¡é‡ç°¡å–®ï¼ˆå¦‚å¤©ç©ºï¼‰
- é¿å…é€†å…‰
- ç´…ç¶ ç‡ˆä½”ç•«é¢ 1/4 åˆ° 1/2

é æœŸçµæœï¼š80-90% åµæ¸¬æˆåŠŸ
</code></pre>

<h4>é€²éšæ¸¬è©¦ï¼ˆé›£åº¦ï¼šâ˜…â˜…â˜…â˜…â˜†ï¼‰</h4>
<p><strong>è¤‡é›œå ´æ™¯</strong></p>
<pre class="codehilite"><code>æŒ‘æˆ°å ´æ™¯ï¼š
1. ç¹å¿™è·¯å£ï¼ˆå¤šçµ„ç´…ç¶ ç‡ˆï¼‰
2. å¤œé–“ç´…ç¶ ç‡ˆ
3. æœ‰æ‹›ç‰Œå¹²æ“¾çš„è¡—é“
4. é›¨å¤©æˆ–é™°å¤©æ‹æ”

æŒ‘æˆ°é»ï¼š
- èƒŒæ™¯è¤‡é›œ
- å…‰ç·šæ¢ä»¶å·®
- å¯èƒ½æœ‰å¤šå€‹ç´…ç¶ ç‡ˆ
- éœ€è¦ç²¾ç¢ºè¾¨è­˜æ˜¯å“ªä¸€å€‹

é æœŸçµæœï¼š60-75% åµæ¸¬æˆåŠŸ
éœ€è¦ï¼šç²¾ç´°èª¿æ•´åƒæ•¸ã€åŠ å…¥é¡å¤–ç¯©é¸æ¢ä»¶
</code></pre>

<h3>ç´…ç¶ ç‡ˆ HSV é¡è‰²ç¯„åœ</h3>
<p>ä¸åŒç‡ˆè™Ÿçš„ HSV ç¯„åœåƒè€ƒï¼š</p>
<table>
<thead>
<tr>
<th>ç‡ˆè™Ÿ</th>
<th>H (è‰²ç›¸)</th>
<th>S (é£½å’Œåº¦)</th>
<th>V (äº®åº¦)</th>
<th>å‚™è¨»</th>
</tr>
</thead>
<tbody>
<tr>
<td>ç´…ç‡ˆ</td>
<td>0-10 æˆ– 170-180</td>
<td>150-255</td>
<td>150-255</td>
<td>äº®èµ·æ™‚é£½å’Œåº¦å’Œäº®åº¦é«˜</td>
</tr>
<tr>
<td>é»ƒç‡ˆ</td>
<td>20-35</td>
<td>150-255</td>
<td>200-255</td>
<td>åé»ƒæ©™è‰²</td>
</tr>
<tr>
<td>ç¶ ç‡ˆ</td>
<td>40-80</td>
<td>100-255</td>
<td>150-255</td>
<td>ç¯„åœè¼ƒå¯¬</td>
</tr>
</tbody>
</table>
<p><strong>æ³¨æ„</strong>ï¼š<br />
- äº®èµ·çš„ç‡ˆè™Ÿï¼šé«˜ Sï¼ˆé£½å’Œåº¦ï¼‰ã€é«˜ Vï¼ˆäº®åº¦ï¼‰<br />
- ç†„æ»…çš„ç‡ˆè™Ÿï¼šä½ Sã€ä½ Vï¼ˆæ¥è¿‘ç°è‰²ï¼‰<br />
- éœ€æ ¹æ“šå¯¦éš›ç…§ç‰‡å¾®èª¿</p>
<h3>å½±åƒå“è³ªæª¢æŸ¥æ¸…å–®</h3>
<p>æ¸¬è©¦å‰è«‹ç¢ºèªï¼š<br />
- [ ] å½±åƒæ ¼å¼ï¼šJPGã€PNG<br />
- [ ] è§£æåº¦ï¼šè‡³å°‘ 640Ã—480ï¼ˆå»ºè­° 1024Ã—768ï¼‰<br />
- [ ] ç´…ç¶ ç‡ˆæ¸…æ™°å¯è¦‹<br />
- [ ] è‡³å°‘ä¸€å€‹ç‡ˆè™Ÿæ˜äº®ç™¼å…‰<br />
- [ ] æ‹æ”è§’åº¦ï¼šæ­£é¢æˆ–å¾®å´é¢ï¼ˆ&lt; 30Â°ï¼‰<br />
- [ ] èƒŒæ™¯ï¼šç›¡é‡ç°¡å–®ï¼ˆå¤©ç©ºæœ€ä½³ï¼‰<br />
- [ ] å…‰ç·šï¼šå……è¶³å‡å‹»<br />
- [ ] ç‡ˆè™Ÿå¤§å°ï¼šæ¯å€‹ç‡ˆè‡³å°‘ 15Ã—15 åƒç´ </p>
<hr />
<h2>âœ… è©³ç´°éœ€æ±‚åˆ—è¡¨</h2>
<h3>éœ€æ±‚ 1ï¼šåŒ¯å…¥å¥—ä»¶èˆ‡å»ºç«‹æ¸¬è©¦åœ–ç‰‡</h3>
<p><strong>èªªæ˜</strong>ï¼šåŒ¯å…¥å¿…è¦å¥—ä»¶ï¼Œä¸¦å»ºç«‹æ¨¡æ“¬ç´…ç¶ ç‡ˆçš„æ¸¬è©¦åœ–ç‰‡ã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python">import cv2
import numpy as np
from google.colab.patches import cv2_imshow

print(&quot;=&quot;*60)
print(&quot;ç´…ç¶ ç‡ˆè¾¨è­˜ç³»çµ±&quot;)
print(&quot;=&quot;*60)

# å»ºç«‹æ¨¡æ“¬ç´…ç¶ ç‡ˆæ¸¬è©¦åœ–ç‰‡
def create_traffic_light(light_on='red'):
    &quot;&quot;&quot;
    å»ºç«‹æ¨¡æ“¬ç´…ç¶ ç‡ˆåœ–ç‰‡

    åƒæ•¸:
        light_on: 'red', 'yellow', 'green' æˆ– 'none'
    &quot;&quot;&quot;
    # å»ºç«‹ 600x400 æ·±ç°è‰²ç•«å¸ƒ
    img = np.ones((600, 400, 3), dtype=np.uint8) * 100

    # ç¹ªè£½ç´…ç¶ ç‡ˆå¤–æ¡†
    cv2.rectangle(img, (150, 100), (250, 450), (30, 30, 30), -1)

    # å®šç¾©ä¸‰å€‹ç‡ˆçš„ä½ç½®
    red_pos = (200, 180)
    yellow_pos = (200, 300)
    green_pos = (200, 420)
    radius = 35

    # ç¹ªè£½ç†„æ»…ç‹€æ…‹çš„ç‡ˆï¼ˆæ·±ç°è‰²ï¼‰
    cv2.circle(img, red_pos, radius, (60, 60, 60), -1)
    cv2.circle(img, yellow_pos, radius, (60, 60, 60), -1)
    cv2.circle(img, green_pos, radius, (60, 60, 60), -1)

    # æ ¹æ“šåƒæ•¸é»äº®å°æ‡‰çš„ç‡ˆ
    if light_on == 'red':
        cv2.circle(img, red_pos, radius, (0, 0, 255), -1)      # BGR: ç´…è‰²
    elif light_on == 'yellow':
        cv2.circle(img, yellow_pos, radius, (0, 255, 255), -1)  # BGR: é»ƒè‰²
    elif light_on == 'green':
        cv2.circle(img, green_pos, radius, (0, 255, 0), -1)    # BGR: ç¶ è‰²

    return img

# å»ºç«‹æ¸¬è©¦åœ–ç‰‡ï¼ˆé è¨­ç´…ç‡ˆäº®ï¼‰
img = create_traffic_light('red')  # å¯æ”¹ç‚º 'yellow' æˆ– 'green'

print(&quot;âœ“ æ¸¬è©¦åœ–ç‰‡å»ºç«‹å®Œæˆ&quot;)
print(f&quot;åœ–ç‰‡å°ºå¯¸: {img.shape[1]} x {img.shape[0]} åƒç´ &quot;)

# é¡¯ç¤ºåŸå§‹æ¸¬è©¦åœ–ç‰‡
print(&quot;\nåŸå§‹æ¸¬è©¦åœ–ç‰‡ï¼š&quot;)
cv2_imshow(img)

# ä¿å­˜åŸåœ–å‰¯æœ¬
img_result = img.copy()
</code></pre>

<hr />
<h3>éœ€æ±‚ 2ï¼šè¨­å®šç´…ç¶ ç‡ˆé¡è‰² HSV ç¯„åœ</h3>
<p><strong>èªªæ˜</strong>ï¼šå®šç¾©ç´…ã€é»ƒã€ç¶ ä¸‰ç¨®ç‡ˆè™Ÿçš„ HSV ç¯„åœã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># å®šç¾©ç´…ç¶ ç‡ˆé¡è‰²ç¯„åœå­—å…¸
traffic_light_colors = {
    'ç´…ç‡ˆ': {
        'lower': np.array([0, 150, 150]),      # HSV ä¸‹é™
        'upper': np.array([10, 255, 255]),     # HSV ä¸Šé™
        'display_color': (0, 0, 255),          # BGR æ ¼å¼ï¼ˆç¹ªè£½ç”¨ï¼‰
        'status': 'STOP'                       # ç‹€æ…‹
    },
    'é»ƒç‡ˆ': {
        'lower': np.array([20, 150, 200]),
        'upper': np.array([35, 255, 255]),
        'display_color': (0, 255, 255),
        'status': 'CAUTION'
    },
    'ç¶ ç‡ˆ': {
        'lower': np.array([40, 100, 150]),
        'upper': np.array([80, 255, 255]),
        'display_color': (0, 255, 0),
        'status': 'GO'
    }
}

print(&quot;âœ“ ç´…ç¶ ç‡ˆé¡è‰²ç¯„åœè¨­å®šå®Œæˆ&quot;)
print(&quot;å°‡åµæ¸¬ä»¥ä¸‹ç‡ˆè™Ÿï¼š&quot;)
for light_name, info in traffic_light_colors.items():
    print(f&quot;  - {light_name} ({info['status']})&quot;)

print(&quot;&quot;)
</code></pre>

<hr />
<h3>éœ€æ±‚ 3ï¼šè½‰æ›è‰²å½©ç©ºé–“ç‚º HSV</h3>
<p><strong>èªªæ˜</strong>ï¼šå°‡ BGR åœ–ç‰‡è½‰æ›ç‚º HSV æ ¼å¼ã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># å°‡åœ–ç‰‡å¾ BGR è½‰æ›ç‚º HSV è‰²å½©ç©ºé–“
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
print(&quot;âœ“ åœ–ç‰‡å·²è½‰æ›ç‚º HSV è‰²å½©ç©ºé–“\n&quot;)
</code></pre>

<hr />
<h3>éœ€æ±‚ 4ï¼šåµæ¸¬ä¸¦æ¨™è¨˜ç´…ç¶ ç‡ˆç‡ˆè™Ÿ</h3>
<p><strong>èªªæ˜</strong>ï¼šéæ­·ä¸‰ç¨®ç‡ˆè™Ÿï¼Œå»ºç«‹é®ç½©ã€å°‹æ‰¾è¼ªå»“ã€ä¸¦é€²è¡Œåœ“å½¢åº¦æª¢æ¸¬ã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># çµ±è¨ˆè®Šæ•¸
detected_lights = []  # å„²å­˜åµæ¸¬åˆ°çš„ç‡ˆè™Ÿ

print(&quot;=&quot;*60)
print(&quot;é–‹å§‹åµæ¸¬ç´…ç¶ ç‡ˆ&quot;)
print(&quot;=&quot;*60)

# éæ­·æ¯ç¨®ç‡ˆè™Ÿ
for light_name, light_info in traffic_light_colors.items():
    print(f&quot;\nåµæ¸¬ {light_name}...&quot;)

    # === æ­¥é©Ÿ 1: å»ºç«‹é¡è‰²é®ç½© ===
    mask = cv2.inRange(
        hsv,
        light_info['lower'],
        light_info['upper']
    )

    # å¯é¸ï¼šå½¢æ…‹å­¸æ“ä½œï¼Œå»é™¤é›œè¨Š
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)

    # å¯é¸ï¼šé¡¯ç¤ºé®ç½©ï¼ˆé™¤éŒ¯ç”¨ï¼‰
    # print(f&quot;{light_name} é®ç½©ï¼š&quot;)
    # cv2_imshow(mask)

    # === æ­¥é©Ÿ 2: å°‹æ‰¾è¼ªå»“ ===
    contours, _ = cv2.findContours(
        mask,
        cv2.RETR_EXTERNAL,
        cv2.CHAIN_APPROX_SIMPLE
    )

    print(f&quot;  æ‰¾åˆ° {len(contours)} å€‹è¼ªå»“&quot;)

    # === æ­¥é©Ÿ 3: ç¯©é¸æœ‰æ•ˆè¼ªå»“ï¼ˆåœ“å½¢åº¦æª¢æ¸¬ï¼‰===
    valid_count = 0
    for contour in contours:
        # è¨ˆç®—è¼ªå»“é¢ç©
        area = cv2.contourArea(contour)

        # éæ¿¾å¤ªå°çš„è¼ªå»“
        if area &lt; 200:  # é¢ç©é–¾å€¼ï¼Œå¯èª¿æ•´
            continue

        # è¨ˆç®—è¼ªå»“çš„å‘¨é•·
        perimeter = cv2.arcLength(contour, True)

        if perimeter == 0:
            continue

        # è¨ˆç®—åœ“å½¢åº¦ï¼š4Ï€ * é¢ç© / å‘¨é•·^2
        # å®Œç¾åœ“å½¢çš„åœ“å½¢åº¦ = 1.0
        # ä¸€èˆ¬æ¥å—ç¯„åœï¼š0.7 ~ 1.3
        circularity = 4 * np.pi * area / (perimeter * perimeter)

        # åªæ¥å—æ¥è¿‘åœ“å½¢çš„è¼ªå»“
        if 0.7 &lt; circularity &lt; 1.3:
            valid_count += 1

            # å–å¾—é‚Šç•ŒçŸ©å½¢ï¼ˆç”¨æ–¼æ¨™è¨˜ï¼‰
            x, y, w, h = cv2.boundingRect(contour)

            # è¨ˆç®—ä¸­å¿ƒé»
            center_x = x + w // 2
            center_y = y + h // 2

            # ç¹ªè£½åœ“å½¢æ¨™è¨˜
            radius = max(w, h) // 2 + 5
            cv2.circle(
                img_result,
                (center_x, center_y),
                radius,
                light_info['display_color'],
                3
            )

            # åŠ ä¸Šæ–‡å­—æ¨™ç±¤
            label = f&quot;{light_name} ({light_info['status']})&quot;
            cv2.putText(
                img_result,
                label,
                (x, y - 10 if y &gt; 40 else y + h + 25),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.7,
                light_info['display_color'],
                2
            )

            # è¨˜éŒ„åµæ¸¬çµæœ
            detected_lights.append({
                'name': light_name,
                'status': light_info['status'],
                'position': (center_x, center_y),
                'area': area,
                'circularity': circularity
            })

            print(f&quot;    âœ“ {light_name}: ä½ç½®({center_x},{center_y}), &quot;
                  f&quot;é¢ç©{area:.0f}px, åœ“å½¢åº¦{circularity:.2f}&quot;)

    if valid_count == 0:
        print(f&quot;  âœ— æœªåµæ¸¬åˆ°æœ‰æ•ˆçš„{light_name}&quot;)

print(&quot;\n&quot; + &quot;=&quot;*60)
</code></pre>

<hr />
<h3>éœ€æ±‚ 5ï¼šåˆ¤æ–·ç´…ç¶ ç‡ˆç‹€æ…‹</h3>
<p><strong>èªªæ˜</strong>ï¼šæ ¹æ“šåµæ¸¬çµæœï¼Œåˆ¤æ–·ç•¶å‰ç´…ç¶ ç‡ˆçš„ç‹€æ…‹ã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># åˆ¤æ–·ç´…ç¶ ç‡ˆç‹€æ…‹
print(&quot;ç´…ç¶ ç‡ˆç‹€æ…‹åˆ¤æ–·&quot;)
print(&quot;=&quot;*60)

if len(detected_lights) == 0:
    current_status = &quot;æœªçŸ¥ï¼ˆç„¡ç‡ˆè™Ÿåµæ¸¬ï¼‰&quot;
    print(&quot;âš ï¸ æœªåµæ¸¬åˆ°ä»»ä½•äº®èµ·çš„ç‡ˆè™Ÿ&quot;)
elif len(detected_lights) == 1:
    # åªæœ‰ä¸€å€‹ç‡ˆäº®
    light = detected_lights[0]
    current_status = f&quot;{light['name']} - {light['status']}&quot;
    print(f&quot;âœ“ ç•¶å‰ç‹€æ…‹: {current_status}&quot;)
else:
    # å¤šå€‹ç‡ˆäº®ï¼ˆç•°å¸¸æƒ…æ³æˆ–èª¤åˆ¤ï¼‰
    print(f&quot;âš ï¸ è­¦å‘Š: åµæ¸¬åˆ° {len(detected_lights)} å€‹äº®ç‡ˆ&quot;)
    print(&quot;å¯èƒ½åŸå› ï¼š&quot;)
    print(&quot;  1. å¤šçµ„ç´…ç¶ ç‡ˆ&quot;)
    print(&quot;  2. èƒŒæ™¯å¹²æ“¾ï¼ˆèª¤åˆ¤ï¼‰&quot;)
    print(&quot;  3. ç‡ˆè™Ÿåˆ‡æ›ç¬é–“&quot;)

    # åˆ—å‡ºæ‰€æœ‰åµæ¸¬åˆ°çš„ç‡ˆ
    for i, light in enumerate(detected_lights, 1):
        print(f&quot;  {i}. {light['name']} - {light['status']}&quot;)

    # å–é¢ç©æœ€å¤§çš„ä½œç‚ºä¸»è¦ç‡ˆè™Ÿ
    main_light = max(detected_lights, key=lambda x: x['area'])
    current_status = f&quot;{main_light['name']} - {main_light['status']} (ä¸»è¦)&quot;
    print(f&quot;\næ¨æ¸¬ä¸»è¦ç‹€æ…‹: {current_status}&quot;)

print(&quot;=&quot;*60 + &quot;\n&quot;)
</code></pre>

<hr />
<h3>éœ€æ±‚ 6ï¼šé¡¯ç¤ºçµæœèˆ‡çµ±è¨ˆ</h3>
<p><strong>èªªæ˜</strong>ï¼šé¡¯ç¤ºè™•ç†çµæœä¸¦è¼¸å‡ºçµ±è¨ˆè³‡è¨Šã€‚</p>
<p><strong>ç¨‹å¼ç¢¼æç¤º</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># åœ¨åœ–ç‰‡ä¸Šé¡¯ç¤ºç‹€æ…‹è³‡è¨Š
info_y = 40
cv2.putText(
    img_result,
    f&quot;Status: {current_status}&quot;,
    (10, info_y),
    cv2.FONT_HERSHEY_SIMPLEX,
    0.8,
    (255, 255, 255),
    2
)

cv2.putText(
    img_result,
    f&quot;Detected: {len(detected_lights)} light(s)&quot;,
    (10, info_y + 35),
    cv2.FONT_HERSHEY_SIMPLEX,
    0.6,
    (255, 255, 255),
    2
)

# é¡¯ç¤ºçµ±è¨ˆ
print(&quot;åµæ¸¬çµ±è¨ˆï¼š&quot;)
print(f&quot;  åµæ¸¬åˆ°çš„ç‡ˆè™Ÿæ•¸é‡: {len(detected_lights)}&quot;)
for light in detected_lights:
    print(f&quot;  - {light['name']}: ä½ç½®{light['position']}&quot;)

# é¡¯ç¤ºåŸåœ–å’Œçµæœ
print(&quot;\nåŸå§‹åœ–ç‰‡ï¼š&quot;)
cv2_imshow(img)

print(&quot;\næ¨™è¨˜å¾Œçš„çµæœï¼š&quot;)
cv2_imshow(img_result)

# å„²å­˜çµæœ
output_filename = 'result_traffic_light.jpg'
cv2.imwrite(output_filename, img_result)
print(f&quot;\nâœ“ çµæœå·²å„²å­˜ç‚º {output_filename}&quot;)
</code></pre>

<hr />
<h2>ğŸ“ å®Œæ•´å¯åŸ·è¡Œç¨‹å¼ç¢¼</h2>
<pre class="codehilite"><code class="language-python"># ========================================
# é¡Œç›®äºŒï¼šç´…ç¶ ç‡ˆè¾¨è­˜ç³»çµ±
# ========================================

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

print(&quot;=&quot;*60)
print(&quot;ç´…ç¶ ç‡ˆè¾¨è­˜ç³»çµ±&quot;)
print(&quot;=&quot;*60)

# === 1. å»ºç«‹æ¸¬è©¦åœ–ç‰‡ ===
def create_traffic_light(light_on='red'):
    &quot;&quot;&quot;å»ºç«‹æ¨¡æ“¬ç´…ç¶ ç‡ˆåœ–ç‰‡&quot;&quot;&quot;
    img = np.ones((600, 400, 3), dtype=np.uint8) * 100
    cv2.rectangle(img, (150, 100), (250, 450), (30, 30, 30), -1)

    red_pos = (200, 180)
    yellow_pos = (200, 300)
    green_pos = (200, 420)
    radius = 35

    # ç¹ªè£½ç†„æ»…ç‹€æ…‹
    cv2.circle(img, red_pos, radius, (60, 60, 60), -1)
    cv2.circle(img, yellow_pos, radius, (60, 60, 60), -1)
    cv2.circle(img, green_pos, radius, (60, 60, 60), -1)

    # é»äº®æŒ‡å®šç‡ˆè™Ÿ
    if light_on == 'red':
        cv2.circle(img, red_pos, radius, (0, 0, 255), -1)
    elif light_on == 'yellow':
        cv2.circle(img, yellow_pos, radius, (0, 255, 255), -1)
    elif light_on == 'green':
        cv2.circle(img, green_pos, radius, (0, 255, 0), -1)

    return img

# å»ºç«‹æ¸¬è©¦åœ–ç‰‡
img = create_traffic_light('red')  # å¯æ”¹ç‚º 'yellow', 'green'
img_result = img.copy()

print(&quot;âœ“ æ¸¬è©¦åœ–ç‰‡å»ºç«‹å®Œæˆ\n&quot;)
print(&quot;åŸå§‹æ¸¬è©¦åœ–ç‰‡ï¼š&quot;)
cv2_imshow(img)

# === 2. è¨­å®šé¡è‰²ç¯„åœ ===
traffic_light_colors = {
    'ç´…ç‡ˆ': {
        'lower': np.array([0, 150, 150]),
        'upper': np.array([10, 255, 255]),
        'display_color': (0, 0, 255),
        'status': 'STOP'
    },
    'é»ƒç‡ˆ': {
        'lower': np.array([20, 150, 200]),
        'upper': np.array([35, 255, 255]),
        'display_color': (0, 255, 255),
        'status': 'CAUTION'
    },
    'ç¶ ç‡ˆ': {
        'lower': np.array([40, 100, 150]),
        'upper': np.array([80, 255, 255]),
        'display_color': (0, 255, 0),
        'status': 'GO'
    }
}

print(&quot;\nâœ“ é¡è‰²ç¯„åœè¨­å®šå®Œæˆ&quot;)

# === 3. è½‰æ›è‰²å½©ç©ºé–“ ===
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# === 4. åµæ¸¬ç‡ˆè™Ÿ ===
detected_lights = []

print(&quot;\n&quot; + &quot;=&quot;*60)
print(&quot;é–‹å§‹åµæ¸¬ç´…ç¶ ç‡ˆ&quot;)
print(&quot;=&quot;*60)

for light_name, light_info in traffic_light_colors.items():
    print(f&quot;\nåµæ¸¬ {light_name}...&quot;)

    # å»ºç«‹é®ç½©
    mask = cv2.inRange(hsv, light_info['lower'], light_info['upper'])

    # å½¢æ…‹å­¸æ“ä½œå»é™¤é›œè¨Š
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)

    # å°‹æ‰¾è¼ªå»“
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    print(f&quot;  æ‰¾åˆ° {len(contours)} å€‹è¼ªå»“&quot;)

    # ç¯©é¸åœ“å½¢è¼ªå»“
    for contour in contours:
        area = cv2.contourArea(contour)

        if area &lt; 200:
            continue

        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue

        # åœ“å½¢åº¦æª¢æ¸¬
        circularity = 4 * np.pi * area / (perimeter * perimeter)

        if 0.7 &lt; circularity &lt; 1.3:
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            center_y = y + h // 2
            radius = max(w, h) // 2 + 5

            # ç¹ªè£½æ¨™è¨˜
            cv2.circle(img_result, (center_x, center_y), radius,
                      light_info['display_color'], 3)

            label = f&quot;{light_name} ({light_info['status']})&quot;
            cv2.putText(img_result, label, (x, y - 10 if y &gt; 40 else y + h + 25),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7,
                       light_info['display_color'], 2)

            # è¨˜éŒ„çµæœ
            detected_lights.append({
                'name': light_name,
                'status': light_info['status'],
                'position': (center_x, center_y),
                'area': area,
                'circularity': circularity
            })

            print(f&quot;    âœ“ {light_name}: ä½ç½®({center_x},{center_y}), &quot;
                  f&quot;é¢ç©{area:.0f}px, åœ“å½¢åº¦{circularity:.2f}&quot;)

# === 5. åˆ¤æ–·ç‹€æ…‹ ===
print(&quot;\n&quot; + &quot;=&quot;*60)
print(&quot;ç´…ç¶ ç‡ˆç‹€æ…‹åˆ¤æ–·&quot;)
print(&quot;=&quot;*60)

if len(detected_lights) == 0:
    current_status = &quot;æœªçŸ¥&quot;
    print(&quot;âš ï¸ æœªåµæ¸¬åˆ°ä»»ä½•äº®èµ·çš„ç‡ˆè™Ÿ&quot;)
elif len(detected_lights) == 1:
    light = detected_lights[0]
    current_status = f&quot;{light['name']} - {light['status']}&quot;
    print(f&quot;âœ“ ç•¶å‰ç‹€æ…‹: {current_status}&quot;)
else:
    print(f&quot;âš ï¸ åµæ¸¬åˆ° {len(detected_lights)} å€‹äº®ç‡ˆ&quot;)
    main_light = max(detected_lights, key=lambda x: x['area'])
    current_status = f&quot;{main_light['name']} - {main_light['status']}&quot;
    print(f&quot;æ¨æ¸¬ä¸»è¦ç‹€æ…‹: {current_status}&quot;)

# === 6. é¡¯ç¤ºçµæœ ===
cv2.putText(img_result, f&quot;Status: {current_status}&quot;, (10, 40),
           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)

cv2.putText(img_result, f&quot;Detected: {len(detected_lights)} light(s)&quot;, (10, 75),
           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

print(&quot;\næ¨™è¨˜å¾Œçš„çµæœï¼š&quot;)
cv2_imshow(img_result)

cv2.imwrite('result_traffic_light.jpg', img_result)
print(&quot;\nâœ“ çµæœå·²å„²å­˜ç‚º result_traffic_light.jpg&quot;)
</code></pre>

<hr />
<h2>ğŸ¯ æ¸¬è©¦å»ºè­°</h2>
<h3>æ¸¬è©¦ 1ï¼šä¸åŒç‡ˆè™Ÿæ¸¬è©¦</h3>
<pre class="codehilite"><code class="language-python"># æ¸¬è©¦ä¸‰ç¨®ç‡ˆè™Ÿ
light_states = ['red', 'yellow', 'green']

for state in light_states:
    print(f&quot;\n{'='*60}&quot;)
    print(f&quot;æ¸¬è©¦: {state.upper()} ç‡ˆ&quot;)
    print(f&quot;{'='*60}&quot;)

    img = create_traffic_light(state)
    # ... åŸ·è¡Œå®Œæ•´åµæ¸¬æµç¨‹ ...

    cv2.imwrite(f'test_{state}_light.jpg', img_result)
</code></pre>

<h3>æ¸¬è©¦ 2ï¼šä½¿ç”¨çœŸå¯¦ç…§ç‰‡</h3>
<pre class="codehilite"><code class="language-python"># ä¸Šå‚³çœŸå¯¦ç´…ç¶ ç‡ˆç…§ç‰‡
from google.colab import files
uploaded = files.upload()

# è®€å–ç…§ç‰‡
img = cv2.imread('your_traffic_light.jpg')

# å…¶é¤˜ç¨‹å¼ç¢¼ç›¸åŒ...
</code></pre>

<h3>æ¸¬è©¦ 3ï¼šèª¿æ•´ HSV ç¯„åœ</h3>
<pre class="codehilite"><code class="language-python"># é‡å°å¯¦éš›ç…§ç‰‡èª¿æ•´ç´…ç‡ˆçš„ HSV ç¯„åœ
red_ranges = [
    ([0, 150, 150], [10, 255, 255]),    # åš´æ ¼
    ([0, 120, 120], [10, 255, 255]),    # å¯¬é¬†
    ([0, 100, 100], [15, 255, 255]),    # æ›´å¯¬é¬†
]

for lower, upper in red_ranges:
    mask = cv2.inRange(hsv, np.array(lower), np.array(upper))
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    valid = sum(1 for c in contours if cv2.contourArea(c) &gt; 200)
    print(f&quot;H:{lower[0]}-{upper[0]}, S:{lower[1]}+, V:{lower[2]}+: {valid} å€‹ç´…ç‡ˆ&quot;)
</code></pre>

<hr />
<h2>ğŸš€ å»¶ä¼¸æŒ‘æˆ°ï¼ˆé¸åšï¼‰</h2>
<h3>æŒ‘æˆ° 1ï¼šåµæ¸¬ç´…ç¶ ç‡ˆæ–¹å‘ï¼ˆç›´è¡Œ/å·¦è½‰/å³è½‰ï¼‰</h3>
<pre class="codehilite"><code class="language-python"># æ ¹æ“šç®­é ­å½¢ç‹€åˆ¤æ–·æ–¹å‘
# æç¤ºï¼šä½¿ç”¨æ¨¡æ¿åŒ¹é…æˆ–æ›´è¤‡é›œçš„å½¢ç‹€åˆ†æ

# å®šç¾©ç®­é ­é¡å‹
arrow_types = {
    'ç›´è¡Œ': 'straight',
    'å·¦è½‰': 'left',
    'å³è½‰': 'right'
}

# å¯ä»¥ä½¿ç”¨è¼ªå»“çš„é•·å¯¬æ¯”ã€æ–¹å‘ç­‰ç‰¹å¾µ
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    aspect_ratio = w / h

    if aspect_ratio &gt; 1.2:
        arrow_type = 'å·¦è½‰æˆ–å³è½‰'
    else:
        arrow_type = 'ç›´è¡Œ'
</code></pre>

<h3>æŒ‘æˆ° 2ï¼šè¨ˆç®—ç´…ç¶ ç‡ˆå‰©é¤˜æ™‚é–“</h3>
<pre class="codehilite"><code class="language-python"># å¦‚æœç´…ç¶ ç‡ˆæœ‰æ•¸å­—é¡¯ç¤ºï¼Œä½¿ç”¨ OCR è¾¨è­˜
# éœ€è¦é¡å¤–çš„ pytesseract å¥—ä»¶

import pytesseract

# æ“·å–æ•¸å­—é¡¯ç¤ºå€åŸŸ
number_region = img[y:y+h, x:x+w]

# è½‰æ›ç‚ºç°éš
gray_region = cv2.cvtColor(number_region, cv2.COLOR_BGR2GRAY)

# OCR è¾¨è­˜
text = pytesseract.image_to_string(gray_region, config='--psm 6 digits')
remaining_time = text.strip()

print(f&quot;å‰©é¤˜æ™‚é–“: {remaining_time} ç§’&quot;)
</code></pre>

<h3>æŒ‘æˆ° 3ï¼šå½±ç‰‡å³æ™‚è¾¨è­˜</h3>
<pre class="codehilite"><code class="language-python"># è™•ç†å½±ç‰‡ä¸­çš„ç´…ç¶ ç‡ˆ
cap = cv2.VideoCapture('traffic_video.mp4')

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # å°æ¯ä¸€å¹€é€²è¡Œç´…ç¶ ç‡ˆåµæ¸¬
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # ... å®Œæ•´åµæ¸¬æµç¨‹ ...

    # é¡¯ç¤ºçµæœ
    cv2_imshow(frame)

cap.release()
</code></pre>

<h3>æŒ‘æˆ° 4ï¼šå¤šçµ„ç´…ç¶ ç‡ˆè¾¨è­˜</h3>
<pre class="codehilite"><code class="language-python"># åœ¨è¤‡é›œå ´æ™¯ä¸­è¾¨è­˜å¤šçµ„ç´…ç¶ ç‡ˆ
# ä¸¦æ¨™è¨»ã€Œæˆ‘æ–¹ã€å’Œã€Œå°å‘ã€

# æ ¹æ“šä½ç½®åˆ¤æ–·
def classify_traffic_light(center_y, img_height):
    &quot;&quot;&quot;æ ¹æ“šå‚ç›´ä½ç½®åˆ¤æ–·ç´…ç¶ ç‡ˆæ˜¯å“ªä¸€æ–¹çš„&quot;&quot;&quot;
    if center_y &lt; img_height * 0.4:
        return &quot;å°å‘&quot;
    elif center_y &gt; img_height * 0.6:
        return &quot;æˆ‘æ–¹&quot;
    else:
        return &quot;å´å‘&quot;

# ç‚ºæ¯å€‹åµæ¸¬åˆ°çš„ç‡ˆåŠ ä¸Šåˆ†é¡
for light in detected_lights:
    classification = classify_traffic_light(light['position'][1], img.shape[0])
    light['classification'] = classification
    print(f&quot;{light['name']} - {classification}&quot;)
</code></pre>

<hr />
<h2>ğŸ”§ é™¤éŒ¯æŠ€å·§</h2>
<h3>å•é¡Œ 1ï¼šåµæ¸¬ä¸åˆ°ç´…ç¶ ç‡ˆ</h3>
<p><strong>è¨ºæ–·å·¥å…·</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># é¡¯ç¤º HSV é®ç½©ï¼Œæª¢æŸ¥é¡è‰²ç¯„åœæ˜¯å¦æ­£ç¢º
for light_name, light_info in traffic_light_colors.items():
    mask = cv2.inRange(hsv, light_info['lower'], light_info['upper'])
    print(f&quot;\n{light_name} é®ç½©ï¼š&quot;)
    cv2_imshow(mask)

    # æª¢æŸ¥é®ç½©ä¸­çš„ç™½è‰²åƒç´ æ•¸é‡
    white_pixels = cv2.countNonZero(mask)
    total_pixels = mask.shape[0] * mask.shape[1]
    percentage = (white_pixels / total_pixels) * 100

    print(f&quot;{light_name} é®ç½©è¦†è“‹ç‡: {percentage:.2f}%&quot;)

    if percentage &lt; 0.1:
        print(f&quot;âš ï¸ {light_name} é®ç½©å¹¾ä¹æ²’æœ‰å…§å®¹ï¼Œè«‹èª¿æ•´ HSV ç¯„åœ&quot;)
</code></pre>

<h3>å•é¡Œ 2ï¼šèƒŒæ™¯å¹²æ“¾ï¼ˆèª¤åˆ¤ï¼‰</h3>
<p><strong>è§£æ±ºæ–¹æ³•</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># æ–¹æ³• 1ï¼šæé«˜é¢ç©é–¾å€¼
min_area = 500  # å¢åŠ åˆ° 500 æˆ– 1000

# æ–¹æ³• 2ï¼šåŠ å…¥åœ“å½¢åº¦æª¢æ¸¬ï¼ˆå·²åœ¨ç¨‹å¼ä¸­ï¼‰
if 0.7 &lt; circularity &lt; 1.3:  # åªæ¥å—æ¥è¿‘åœ“å½¢

# æ–¹æ³• 3ï¼šé™åˆ¶åµæ¸¬å€åŸŸï¼ˆå¦‚æœçŸ¥é“ç´…ç¶ ç‡ˆå¤§æ¦‚ä½ç½®ï¼‰
# åªåœ¨ç•«é¢ä¸ŠåŠéƒ¨åµæ¸¬
roi_y_start = 0
roi_y_end = img.shape[0] // 2
roi = hsv[roi_y_start:roi_y_end, :]

mask = cv2.inRange(roi, light_info['lower'], light_info['upper'])

# æ–¹æ³• 4ï¼šåŠ å…¥ä½ç½®é—œä¿‚æª¢æ¸¬
# ç´…ç¶ ç‡ˆçš„ä¸‰å€‹ç‡ˆæ‡‰è©²å‚ç›´æˆ–æ°´å¹³æ’åˆ—
def check_alignment(lights):
    &quot;&quot;&quot;æª¢æŸ¥ç‡ˆè™Ÿæ˜¯å¦å°é½Šï¼ˆå‚ç›´æˆ–æ°´å¹³ï¼‰&quot;&quot;&quot;
    if len(lights) &lt; 2:
        return True

    positions = [light['position'] for light in lights]

    # æª¢æŸ¥å‚ç›´å°é½Šï¼ˆx åº§æ¨™ç›¸è¿‘ï¼‰
    x_coords = [pos[0] for pos in positions]
    x_variance = np.var(x_coords)

    # æª¢æŸ¥æ°´å¹³å°é½Šï¼ˆy åº§æ¨™ç›¸è¿‘ï¼‰
    y_coords = [pos[1] for pos in positions]
    y_variance = np.var(y_coords)

    # å¦‚æœ x æˆ– y åº§æ¨™çš„è®Šç•°æ•¸å¾ˆå°ï¼Œè¡¨ç¤ºå°é½Š
    return x_variance &lt; 100 or y_variance &lt; 100
</code></pre>

<h3>å•é¡Œ 3ï¼šå¤œé–“æˆ–æš—è™•åµæ¸¬å¤±æ•—</h3>
<p><strong>è§£æ±ºæ–¹æ³•</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># æ–¹æ³• 1ï¼šé™ä½ V (äº®åº¦) çš„ä¸‹é™
'ç´…ç‡ˆ': {
    'lower': np.array([0, 150, 100]),  # V å¾ 150 é™åˆ° 100
    'upper': np.array([10, 255, 255]),
    ...
}

# æ–¹æ³• 2ï¼šå½±åƒé è™•ç† - æé«˜äº®åº¦å’Œå°æ¯”åº¦
img_enhanced = cv2.convertScaleAbs(img, alpha=1.5, beta=30)

# æ–¹æ³• 3ï¼šä½¿ç”¨è‡ªé©æ‡‰è™•ç†
# æ ¹æ“šå½±åƒçš„å¹³å‡äº®åº¦å‹•æ…‹èª¿æ•´ HSV ç¯„åœ
mean_brightness = np.mean(cv2.cvtColor(img, cv2.COLOR_BGR2GRAY))

if mean_brightness &lt; 100:  # æš—è™•
    v_min = 80
else:  # äº®è™•
    v_min = 150
</code></pre>

<h3>å•é¡Œ 4ï¼šç´…è‰²åµæ¸¬ä¸å®Œæ•´</h3>
<p><strong>åŸå› </strong>ï¼šç´…è‰²åœ¨ HSV æ©«è·¨ 0-10 å’Œ 170-180</p>
<p><strong>å®Œæ•´è§£æ±ºæ–¹æ³•</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python"># ç´…ç‡ˆéœ€è¦å…©å€‹ HSV ç¯„åœ
red_lower1 = np.array([0, 150, 150])
red_upper1 = np.array([10, 255, 255])

red_lower2 = np.array([170, 150, 150])
red_upper2 = np.array([180, 255, 255])

# å»ºç«‹å…©å€‹é®ç½©ä¸¦åˆä½µ
mask_red1 = cv2.inRange(hsv, red_lower1, red_upper1)
mask_red2 = cv2.inRange(hsv, red_lower2, red_upper2)
mask_red = cv2.bitwise_or(mask_red1, mask_red2)

# ä½¿ç”¨åˆä½µå¾Œçš„é®ç½©
contours, _ = cv2.findContours(mask_red, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
</code></pre>

<hr />
<h2>ğŸ’¡ å¸¸è¦‹å•é¡Œ FAQ</h2>
<h3>Q1: ç‚ºä»€éº¼è¦ä½¿ç”¨åœ“å½¢åº¦æª¢æ¸¬ï¼Ÿ</h3>
<p><strong>A:</strong> ç´…ç¶ ç‡ˆçš„ç‡ˆè™Ÿæ˜¯åœ“å½¢çš„ï¼Œåœ“å½¢åº¦æª¢æ¸¬å¯ä»¥ï¼š<br />
1. éæ¿¾æ‰çŸ©å½¢çš„æ‹›ç‰Œã€çª—æˆ¶<br />
2. éæ¿¾æ‰ä¸è¦å‰‡å½¢ç‹€çš„é›œè¨Š<br />
3. æé«˜åµæ¸¬æº–ç¢ºåº¦</p>
<pre class="codehilite"><code class="language-python"># åœ“å½¢åº¦å…¬å¼ï¼š4Ï€ Ã— é¢ç© / å‘¨é•·Â²
# å®Œç¾åœ“å½¢ = 1.0
# æ­£æ–¹å½¢ â‰ˆ 0.785
# é•·æ–¹å½¢ &lt; 0.785

circularity = 4 * np.pi * area / (perimeter ** 2)

# æˆ‘å€‘æ¥å— 0.7 ~ 1.3 çš„ç¯„åœ
# è€ƒæ…®åˆ°å¯¦éš›æ‹æ”è§’åº¦ã€åƒç´ åŒ–ç­‰å› ç´ 
</code></pre>

<h3>Q2: å¦‚ä½•å€åˆ†ç´…ç¶ ç‡ˆå’Œå…¶ä»–ç´…/ç¶ è‰²ç‰©é«”ï¼Ÿ</h3>
<p><strong>A:</strong> å¤šé‡ç¯©é¸æ¢ä»¶ï¼š</p>
<ol>
<li><strong>é¡è‰²</strong> - HSV ç¯„åœï¼ˆäº®èµ·çš„ç‡ˆé«˜é£½å’Œåº¦ã€é«˜äº®åº¦ï¼‰</li>
<li><strong>å½¢ç‹€</strong> - åœ“å½¢åº¦æª¢æ¸¬</li>
<li><strong>å¤§å°</strong> - é¢ç©é–¾å€¼</li>
<li><strong>ä½ç½®</strong> - ç´…ç¶ ç‡ˆé€šå¸¸åœ¨ç•«é¢ä¸Šæ–¹</li>
<li><strong>æ•¸é‡</strong> - ä¸‰å€‹ç‡ˆï¼ˆç´…é»ƒç¶ ï¼‰</li>
<li><strong>å°é½Š</strong> - å‚ç›´æˆ–æ°´å¹³æ’åˆ—</li>
</ol>
<pre class="codehilite"><code class="language-python"># ç¶œåˆåˆ¤æ–·å‡½æ•¸
def is_traffic_light(contour, hsv, img_height):
    area = cv2.contourArea(contour)

    # æª¢æŸ¥ 1: å¤§å°
    if area &lt; 200 or area &gt; 10000:
        return False

    # æª¢æŸ¥ 2: åœ“å½¢åº¦
    perimeter = cv2.arcLength(contour, True)
    circularity = 4 * np.pi * area / (perimeter ** 2)
    if not (0.7 &lt; circularity &lt; 1.3):
        return False

    # æª¢æŸ¥ 3: ä½ç½®ï¼ˆç´…ç¶ ç‡ˆé€šå¸¸ä¸åœ¨ç•«é¢åº•éƒ¨ï¼‰
    x, y, w, h = cv2.boundingRect(contour)
    if y &gt; img_height * 0.8:
        return False

    return True
</code></pre>

<h3>Q3: ç‚ºä»€éº¼æœ‰æ™‚å€™æœƒåŒæ™‚åµæ¸¬åˆ°å¤šå€‹ç‡ˆï¼Ÿ</h3>
<p><strong>A:</strong> å¯èƒ½åŸå› ï¼š<br />
1. <strong>åˆ‡æ›ç¬é–“</strong>ï¼šé»ƒç‡ˆæ™‚ç´…ç‡ˆå‰›ç†„æ»…ã€ç¶ ç‡ˆæœªäº®<br />
2. <strong>å¤šçµ„ç´…ç¶ ç‡ˆ</strong>ï¼šè·¯å£æœ‰å¤šå€‹æ–¹å‘çš„ç´…ç¶ ç‡ˆ<br />
3. <strong>åƒæ•¸éæ–¼å¯¬é¬†</strong>ï¼šHSV ç¯„åœå¤ªå¯¬ï¼Œèª¤åˆ¤å…¶ä»–ç‰©é«”</p>
<p><strong>è™•ç†æ–¹æ³•</strong>ï¼š</p>
<pre class="codehilite"><code class="language-python">if len(detected_lights) &gt; 1:
    # æ–¹æ³• 1: å–é¢ç©æœ€å¤§çš„
    main_light = max(detected_lights, key=lambda x: x['area'])

    # æ–¹æ³• 2: æª¢æŸ¥æ˜¯å¦ç‚ºåŒä¸€çµ„ç´…ç¶ ç‡ˆ
    # å¦‚æœä¸‰å€‹ç‡ˆå‚ç›´æ’åˆ—ä¸”é–“è·ç›¸ä¼¼ï¼Œå‰‡ç‚ºåŒä¸€çµ„
    def is_same_group(lights):
        if len(lights) != 3:
            return False

        # æŒ‰ y åº§æ¨™æ’åº
        lights_sorted = sorted(lights, key=lambda x: x['position'][1])

        # æª¢æŸ¥ x åº§æ¨™æ˜¯å¦ç›¸è¿‘ï¼ˆå‚ç›´æ’åˆ—ï¼‰
        x_coords = [l['position'][0] for l in lights_sorted]
        x_std = np.std(x_coords)

        if x_std &gt; 20:  # x åº§æ¨™å·®ç•°å¤ªå¤§
            return False

        # æª¢æŸ¥é–“è·æ˜¯å¦å‡å‹»
        y1, y2, y3 = [l['position'][1] for l in lights_sorted]
        gap1 = y2 - y1
        gap2 = y3 - y2

        if abs(gap1 - gap2) &lt; 20:  # é–“è·ç›¸ä¼¼
            return True

        return False
</code></pre>

<h3>Q4: å¦‚ä½•è™•ç†å‚¾æ–œæ‹æ”çš„ç´…ç¶ ç‡ˆï¼Ÿ</h3>
<p><strong>A:</strong> æ–¹æ³•ï¼š</p>
<ol>
<li><strong>æ”¾å¯¬åœ“å½¢åº¦ç¯„åœ</strong>ï¼š</li>
</ol>
<pre class="codehilite"><code class="language-python"># å‚¾æ–œè§’åº¦æœƒè®“åœ“å½¢çœ‹èµ·ä¾†åƒæ©¢åœ“
# æ”¾å¯¬åœ“å½¢åº¦ç¯„åœåˆ° 0.6 ~ 1.4
if 0.6 &lt; circularity &lt; 1.4:
    # æ¥å—
</code></pre>

<ol>
<li><strong>ä½¿ç”¨æ©¢åœ“æª¢æ¸¬</strong>ï¼š</li>
</ol>
<pre class="codehilite"><code class="language-python"># ä½¿ç”¨ OpenCV çš„æ©¢åœ“æ“¬åˆ
if len(contour) &gt;= 5:  # è‡³å°‘éœ€è¦ 5 å€‹é»
    ellipse = cv2.fitEllipse(contour)
    (center, axes, angle) = ellipse

    # æª¢æŸ¥é•·çŸ­è»¸æ¯”ä¾‹
    major_axis = max(axes)
    minor_axis = min(axes)
    ratio = major_axis / minor_axis

    if ratio &lt; 2.0:  # ä¸æ˜¯å¤ªæ‰çš„æ©¢åœ“
        # é€™å¯èƒ½æ˜¯å‚¾æ–œçš„ç´…ç¶ ç‡ˆ
        pass
</code></pre>

<h3>Q5: å¯ä»¥ç”¨åœ¨è¡Œè»Šè¨˜éŒ„å™¨æˆ–è‡ªé§•è»Šå—ï¼Ÿ</h3>
<p><strong>A:</strong> å¯ä»¥ï¼Œä½†éœ€è¦åŠ å¼·ï¼š</p>
<p><strong>åŸºç¤ç‰ˆæœ¬ï¼ˆæœ¬é¡Œç›®ï¼‰</strong>ï¼š<br />
- é©åˆï¼šéœæ…‹åœ–ç‰‡ã€ç°¡å–®å ´æ™¯<br />
- é™åˆ¶ï¼šé€Ÿåº¦ã€æº–ç¢ºç‡ã€ç©©å®šæ€§</p>
<p><strong>é€²éšç‰ˆæœ¬ï¼ˆå¯¦éš›æ‡‰ç”¨ï¼‰</strong>ï¼š<br />
1. <strong>ä½¿ç”¨æ·±åº¦å­¸ç¿’</strong>ï¼šYOLOã€Faster R-CNN<br />
2. <strong>å³æ™‚è™•ç†</strong>ï¼šå„ªåŒ–æ¼”ç®—æ³•ã€ä½¿ç”¨ GPU<br />
3. <strong>è¿½è¹¤æŠ€è¡“</strong>ï¼šå¡çˆ¾æ›¼æ¿¾æ³¢å™¨ã€å…‰æµè¿½è¹¤<br />
4. <strong>å¤šå¹€èåˆ</strong>ï¼šçµåˆå‰å¾Œå¹€è³‡è¨Šæé«˜ç©©å®šæ€§<br />
5. <strong>è·é›¢ä¼°è¨ˆ</strong>ï¼šæ ¹æ“šç´…ç¶ ç‡ˆå¤§å°ä¼°è¨ˆè·é›¢</p>
<pre class="codehilite"><code class="language-python"># é€²éšï¼šä½¿ç”¨ YOLO åµæ¸¬ç´…ç¶ ç‡ˆï¼ˆéœ€è¦é è¨“ç·´æ¨¡å‹ï¼‰
import cv2
import numpy as np

# è¼‰å…¥ YOLO æ¨¡å‹ï¼ˆéœ€è¦äº‹å…ˆè¨“ç·´æˆ–ä¸‹è¼‰ï¼‰
net = cv2.dnn.readNet(&quot;yolo_traffic_light.weights&quot;, &quot;yolo_traffic_light.cfg&quot;)

# é€²è¡Œåµæ¸¬
blob = cv2.dnn.blobFromImage(img, 1/255.0, (416, 416), swapRB=True, crop=False)
net.setInput(blob)
outputs = net.forward(net.getUnconnectedOutLayersNames())

# è™•ç†è¼¸å‡º...
</code></pre>

<hr />
<h2>ğŸ“Š è©•åˆ†æ¨™æº–</h2>
<table>
<thead>
<tr>
<th>é …ç›®</th>
<th>é…åˆ†</th>
<th>è©•åˆ†é‡é»</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>åŠŸèƒ½å®Œæ•´æ€§</strong></td>
<td>40%</td>
<td>æ­£ç¢ºåµæ¸¬ç´…é»ƒç¶ ä¸‰ç¨®ç‡ˆè™Ÿã€åœ“å½¢åº¦æª¢æ¸¬ã€ç‹€æ…‹åˆ¤æ–·</td>
</tr>
<tr>
<td><strong>ç¨‹å¼ç¢¼å“è³ª</strong></td>
<td>25%</td>
<td>çµæ§‹æ¸…æ™°ã€è¨»è§£å®Œæ•´ã€è®Šæ•¸å‘½åè¦ç¯„</td>
</tr>
<tr>
<td><strong>åŸ·è¡Œçµæœ</strong></td>
<td>20%</td>
<td>èƒ½æ­£ç¢ºè¾¨è­˜ç´…ç¶ ç‡ˆç‹€æ…‹ã€æ¨™è¨˜æ¸…æ™°</td>
</tr>
<tr>
<td><strong>æ¸¬è©¦å ±å‘Š</strong></td>
<td>10%</td>
<td>å®Œæ•´è¨˜éŒ„æ¸¬è©¦éç¨‹èˆ‡å¿ƒå¾—åæ€</td>
</tr>
<tr>
<td><strong>å»¶ä¼¸æŒ‘æˆ°</strong></td>
<td>5%</td>
<td>å®Œæˆè‡³å°‘ä¸€é …å»¶ä¼¸æŒ‘æˆ°ï¼ˆåŠ åˆ†é …ï¼‰</td>
</tr>
</tbody>
</table>
<hr />
<h2>ğŸ“š å­¸ç¿’è³‡æº</h2>
<h3>åƒè€ƒæ–‡ä»¶</h3>
<ul>
<li>ä¸»è¦æ•™å­¸ï¼š<code>opencv_imageclassfy_b05.md</code></li>
<li>OpenCV å®˜æ–¹ï¼š<a href="https://docs.opencv.org/4.x/df/d9d/tutorial_py_colorspaces.html">Color Spaces</a></li>
<li>è¼ªå»“åˆ†æï¼š<a href="https://docs.opencv.org/4.x/dd/d49/tutorial_py_contour_features.html">Contour Features</a></li>
</ul>
<h3>ç›¸é—œå‡½æ•¸</h3>
<ul>
<li><code>cv2.cvtColor()</code>ï¼šè‰²å½©ç©ºé–“è½‰æ›</li>
<li><code>cv2.inRange()</code>ï¼šå»ºç«‹é¡è‰²é®ç½©</li>
<li><code>cv2.findContours()</code>ï¼šå°‹æ‰¾è¼ªå»“</li>
<li><code>cv2.contourArea()</code>ï¼šè¨ˆç®—è¼ªå»“é¢ç©</li>
<li><code>cv2.arcLength()</code>ï¼šè¨ˆç®—è¼ªå»“å‘¨é•·</li>
<li><code>cv2.morphologyEx()</code>ï¼šå½¢æ…‹å­¸æ“ä½œ</li>
</ul>
<h3>å¯¦éš›æ‡‰ç”¨</h3>
<ul>
<li>è‡ªå‹•é§•é§›ç³»çµ±</li>
<li>äº¤é€šç›£æ§ç³»çµ±</li>
<li>è¡Œè»Šè¼”åŠ©ç³»çµ±ï¼ˆADASï¼‰</li>
<li>æ™ºæ…§åŸå¸‚äº¤é€šç®¡ç†</li>
</ul>
<hr />
<p><strong>ç¥å­¸ç¿’é †åˆ©ï¼ç´…ç¶ ç‡ˆè¾¨è­˜æ˜¯é›»è…¦è¦–è¦ºçš„ç¶“å…¸æ‡‰ç”¨ï¼ŒæŒæ¡å¾Œå¯ä»¥æ‡‰ç”¨åˆ°æ›´å¤šå¯¦éš›å ´æ™¯ï¼</strong> ğŸš¦</p></div>
    
    <!-- Highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <!-- Mermaid -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            "startOnLoad": true,
            "theme": "dark",
            "securityLevel": "loose"
});
    </script>
</body>
</html>